// memory template
    // a method
    /* public java.lang.reflect.Constructor<T> java.lang.Class.getConstructor
    (java.lang.Class<?>[]) throws java.lang.NoSuchMethodException,
        java.lang.SecurityException
        */

Class<?> c = Class.forName(args[0]);
Method[] allMethods = c.getDeclaredMethods();
for (Method m : allMethods) {
    out.format("%s%n", m.toGenericString());

    out.format(fmt, "ReturnType", m.getReturnType());
    out.format(fmt, "GenericReturnType", m.getGenericReturnType());

    Class<?>[] pType  = m.getParameterTypes();
    Type[] gpType = m.getGenericParameterTypes();
    for (int i = 0; i < pType.length; i++) {
        out.format(fmt,"ParameterType", pType[i]);
        out.format(fmt,"GenericParameterType", gpType[i]);
    }

    Class<?>[] xType  = m.getExceptionTypes();
    Type[] gxType = m.getGenericExceptionTypes();
    for (int i = 0; i < xType.length; i++) {
        out.format(fmt,"ExceptionType", xType[i]);
        out.format(fmt,"GenericExceptionType", gxType[i]);
    }

    out.format("  Modifiers:  %s%n",
            Modifier.toString(m.getModifiers()));
    out.format("  [ synthetic=%-5b var_args=%-5b bridge=%-5b ]%n",
            m.isSynthetic(), m.isVarArgs(), m.isBridge());

    /* FIXME: what is synthetic or compiler-generated bridge?
        This occurs because String implements the parameterized interface Comparable. 
        During type erasure, the argument type of the inherited method 
        Comparable.compareTo() is changed from java.lang.Object to java.lang.String. 
        Since the parameter types for the compareTo methods in Comparable and String 
        no longer match after erasure, overriding can not occur. In all other 
        circumstances, this would produce a compile-time error because the interface
        is not implemented. The addition of the bridge method avoids this problem.

        FIXME:what is synthetic method?
            method generated by compiler instead of programmer
    */
}

