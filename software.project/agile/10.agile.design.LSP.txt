Liskov替换原则
    
    IS-A太宽泛，不能够作为判定子类的标准

    子类型能够完全能够替换基类型
        子类的可替换性使得基于基类编写的模块在不需要修改的情况下能够扩展

    衡量子类的标准是“可替换性”

        可替换性可通过显式或隐式的契约来定义
            在单元测试中指定契约

            从基于基类编写的模块来考虑，子类是否真的能替换基类

            从使用者的角度来检查概念

        应该仔细观察概念和概念之间的区别
            只有一个概念能够完全包括另一个概念时，才使用继承关系
            子类从集合的角度来看，应该是基类的超集

            子类提供的是基类功能的扩展，而不能修改和减少基类的功能 
                任何子类方法都不应该覆写它的任何基类中已经实现了的方法

                Square不能成为Rectangle的子类
                    因为Rectangle具有setWidth, setHeight方法
                    而Square从概念上只有setLenght方法，退化了Rectangle的方法


    违反LSP的情况：

        子类中有和基类的假设或概念不同的东西
            比如直线和线段的概念有明显不同，直线的长度是无限的。线段的长度是有限的。
            判断直线和y轴性相交的和线段是否和y轴相交是不一样的
            所以线段不可以是直线的基类

            可以提取一个基类，将直线和线段相关的公共部分抽取出来
                Line<|---LineSegment
                    |
                    V
                LineObject<|---Line  LineObject是Line，LineSegment中公共部分
                          <|---LineSegment

                如果一组类有一些公共的职能，应该将公共职能提取到超类中

        在派生类中将基类的函数退化
            覆盖基类函数，并在子类函数中什么都不做
            存在这种情况，并不一定总是违反LSP。但是需要注意。

        从派生类中抛出基类中没有声明的异常
            要么在基类中声明，要么在子类中不抛出


